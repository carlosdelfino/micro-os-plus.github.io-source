---
layout: page
permalink: /articles/arm-com-2016-03-10/
title: 'Article: CMSIS++: a proposal for a future CMSIS, written in C++'
author: Liviu Ionescu

date: 2016-03-10 13:10:00 +0200

tags:
  - arm
  - cmsis
  - c++
  - cmsis++
  - rtos

---

<small>(This article was published in the [ARM Connected Community ](http://community.arm.com/groups/tools/blog/2014/07/17/gnu-arm-eclipse-open-source-tools-with-experimental-cmsis-pack-support) blog, on 10.03.2016).</small>

## Overview

CMSIS++ is a portable, vendor-independent hardware abstraction layer intended for C++ embedded applications, designed with special consideration for the industry standard ARM Cortex-M processor series.

The original ARM Keil name stands for **Cortex Microcontroller Software Interface Standard**, and the CMSIS++ design inherits the good things from ARM CMSIS but goes one step further and ventures into the world of C++; as such, CMSIS++ it is **not** a C++ wrapper running on top of the ARM CMSIS APIs, but a set of completely newly designed C++ APIs, with C APIs supported as wrappers on top of the native C++ APIs.

## The CMSIS++ RTOS APIs

There are many components in CMSIS++, but since everything revolves around the **C++ RTOS API**, this was the first one defined and is presented here.

The CMSIS++ RTOS APIs actually define several interfaces, two in C++, two in C and one internal, in C++. The relationships between them is presented below:

![CMSIS++ RTOS API]({{ site.baseurl }}/assets/images/2016/cmsis-plus-rtos-overview.png)

### The native RTOS C++ API

This is the native RTOS interface, implemented in C++, and providing the entire RTOS functionality.

The classes are grouped under the `os::rtos` namespace, and, to access them, C++ applications must include the `<cmsis-plus/rtos/os.h>` header.

Objects can be instantiated from native classes in the usual C++ way, and can be allocated statically, dynamically on the caller stack or even dynamically on the heap.

Inspired by the POSIX threads usage model, all CMSIS++ native objects can be instantiated in two ways:

* a simple, minimalistic, default way, with a default constructor, or, if not possible, a constructor with the minimum number of arguments.
* a fully configurable, maximal way, by using a set of specific attributes, passed as a first parameter to a separate constructor.

For example, to create a thread with default settings, only the pointer to the thread function and a pointer to the function arguments need to be specified, while a thread with custom settings can also have a custom priority, a static stack, and possibly other custom settings.

A simple example that counts 5 seconds and quits:

```
#include <cmsis-plus/rtos/os.h>
#include <cmsis-plus/diag/trace.h>

using namespace os;

// Define the thread function.
// Native threads can have only one pointer parameter.
void*
func(void* args)
{
  for (int i = 0; i < 5; i++).
    {
      trace::printf("%d sec\n", i);

      // Wait for one second.
      rtos::Systick_clock::sleep_for(rtos::Systick_clock::frequency_hz);
    }
  return nullptr;
}

// in CMSIS++, os_main() is guaranteed to run on a thread.
int
os_main(int argc, char* argv[])
{
  // Create a new native thread, with function and no arguments.
  // The thread is automatically destroyed at the end of the os_main() function.
  rtos::Thread th { func, nullptr };

  // Wait for thread to terminate.
  th.join();

  trace::puts("done.");
  return 0;
}
```

The native CMSIS++ thread is basically a POSIX thread, with some additional functionality.

Similarly, synchronisation objects can be created with the usual C++ approach; for example a piece of code that uses a mutex to protects a counter looks like this:

```
#include <cmsis-plus/rtos/os.h>

// Protected resource (a counter).
typedef struct {
  int count;
} res_t;

// Alloc the resource statically.
res_t res;

// Define a native mutex to protect the resource.
rtos::Mutex mx;

void
count(void)
{
  mx.lock();
  // Not much here, real applications are more complicated.
  res.count++;
  mx.unlock();
}
```

### The ISO C++ Threads API

The ISO C++ threads API is an accurate implementation of the **ISO C++ 11** standard threads specifications.

With the standard threads defined as wrappers over POSIX threads, and having the CMSIS++ native threads very close to POSIX, the implementation was quite straightforward.

The classes are grouped under the `os::estd` namespace, and, to access them, C++ applications must include headers from the `cmsis-plus/iso` folder, like `<cmsis-plus/iso/thread>`. The namespace `std::` and the standard header names (like `<thread>`) could not be used, to avoid clashes with system definitions when building CMSIS++ applications on POSIX host systems. The **e** in `estd` stands for **embedded**, so the namespace is dedicated to **embedded standard** definitions.

A similar example using the standard C++ threads:

```
#include <cmsis-plus/iso/thread>
#include <cmsis-plus/iso/chrono>
#include <cmsis-plus/diag/trace.h>

using namespace os;
// Use the embedded version of 'std::'.
using namespace os::estd;

// Define the thread function.
// Standard threads can have any number of parameters, of any type.
void*
func(int max_count, const char* msg)
{
  for (int i = 0; i < max_count; i++).
    {
      trace::printf("%d sec, %s\n", i, msg);

      // Sleep for one second. <chrono> is very convenient,
      // notice the syntax.
      this_thread::sleep_for (1s);
    }
  return nullptr;
}

// In CMSIS++, os_main() is guaranteed to run on a thread.
int
os_main(int argc, char* argv[])
{
  // Create a new standard thread, and pass two arguments.
  // The thread is automatically destroyed at the end of the os_main() function.
  thread th { func, 5, "bing" };

  // Wait for thread to terminate.
  th.join();

  trace::puts("done.");
  return 0;
}
```

Most of the goodies of the C++ 11 standard can be used, for example RAII mutex locks:

```
#include <cmsis-plus/iso/mutex>

using namespace os;
using namespace os::estd;

// Protected resource (a counter).
typedef struct {
  int count;
} res_t;

// Alloc the resource statically.
res_t res;

// Define a standard mutex to protect the resource.
mutex mx;

void
count(void)
{
  lock_guard<mutex> lck(mx);

  // Not much here, real applications are more complicated.
  res.count++;

  // No need to explicitly unlock, done automatically.
}
```

### The new CMSIS++ RTOS C API

Although fully written in C++, CMSIS++ provides a C API, to be used by C applications. Yes, that's correct, plain C applications can use CMSIS++ without any problems. Just that function names are a bit longer and some of the C++ magic (like running the constructors and the destructors) needs to be done by hand, but otherwise the entire functionality is available.

The C API is defined in the `<cmsis-plus/rtos/c_api.h>` header.

The same simple example that counts 5 seconds and quits, in C would look like:

```
#include <cmsis-plus/rtos/os-c-api.h>
#include <cmsis-plus/diag/trace.h>

// Define the thread function.
// Native threads can have only one pointer parameter.
void*
func(void* args)
{
  for (int i = 0; i < 5; i++).
    {
      trace_printf("%d sec\n", i);

      // Sleep for one second.
      os_systick_clock_sleep_for(OS_INTEGER_SYSTICK_FREQUENCY_HZ);
    }
  return nullptr;
}

// In CMSIS++, os_main() is guaranteed to run on a thread.
int
os_main(int argc, char* argv[])
{
  // Manually allocate space for the thread.    
  os_thread_t th;

  // Initialise a new native thread, with function and no arguments.
  os_thread_create(&th, NULL, func, NULL);

  // Wait for thread to terminate.
  os_thread_join(&th, NULL);

  // Manually destroy the thread.
  os_thread_destroy(&th);

  trace_puts("done.");
  return 0;
}
```

## The ARM CMSIS RTOS C API

Even more, the CMSIS++ C wrapper also implements the original ARM CMSIS API. This is a full and accurate implementation, since this API already passed the ARM CMSIS RTOS validation test.

To access this API, just include the usual `<cmsis_os.h>`.

```
#include <cmsis_os.h>
#include <cmsis-plus/diag/trace.h>

// Define the thread function.
// Native threads can have only one pointer parameter.
void
func(void* args)
{
  for (int i = 0; i < 5; i++).
    {
      trace_printf("%d sec\n", i);

      // Sleep for one second.
      osDelay(osKernelSysTickFrequency);
    }
  // ARM CMSIS threads can return, but there is no way to know this.
}

// The unusal way of defining thread, specific to CMSIS RTOS API.
// It looks like a function, but it is not, it is a macro that defines
// some structures.
osThreadDef(func, 0, 1, 0);

// In CMSIS++, os_main() is guaranteed to run on a thread.
int
os_main(int argc, char* argv[])
{
  // Initialise a new native thread, with function and no arguments.
  osThreadCreate(osThread(func), NULL);

  // No equivalent mechanism to wait for thread to terminate,
  // a complicated synchronisation mechanism must be used.
  // Here just sleep for a longer while.
  osDelay(6 * osKernelSysTickFrequency);

  trace_puts("done.");
  return 0;
}
```

## Conclusions

CMSIS++ is still a young project, and many things need to be addressed, but the core component, the RTOS API, is pretty well defined and awaiting for comments.

For now it may not be perfect (as it tries to be), but it definitely provides a more standard set of primitives, closer to POSIX, and a wider set of APIs, covering both C++ and C applications, and at the same time preserving compatibility with the original ARM CMSIS RTOS.

Any contributions to improve CMSIS++ will be highly appreciated.

## More info

The main source of information for CMSIS++ is the project site [**http://micro-os-plus.github.io/cmsis-plus/**](http://micro-os-plus.github.io/cmsis-plus/).

The Git repositories and all public releases are available from [GitHub](https://github.com/micro-os-plus/cmsis-plus).

For questions and discussions, please use the CMSIS++ section of the [GNU ARM Eclipse forum](https://www.element14.com/community/groups/gnu-arm-eclipse).

For bugs and feature requests, please use the [GitHub issues](https://github.com/micro-os-plus/cmsis-plus/issues/).
